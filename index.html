<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memoriser — cut • substitute • scramble • drag</title>
  <link rel="icon" href="favicon.svg">
  <style>
    :root { --bg:#0b0f14; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --ok:#22c55e; --bad:#ef4444; --outline:#334155; --soft:#1f2937; }
    * { box-sizing: border-box; }
    body { margin:0; font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial,Apple Color Emoji,Segoe UI Emoji; background:var(--bg); color:var(--text); padding-bottom: env(safe-area-inset-bottom); overscroll-behavior-y: contain; }
    header { padding:16px 20px; border-bottom:1px solid var(--soft); position:sticky; top:0; background:linear-gradient(180deg, rgba(11,15,20,.97), rgba(11,15,20,.9)); backdrop-filter: blur(8px); z-index:5 }
    header h1 { margin:0 0 4px; font-weight:700; font-size:18px }
    header p { margin:0; color:var(--muted); font-size:12px }

    .container { display:grid; grid-template-columns: 1fr 1fr; gap:16px; padding:16px; }
    @media (max-width: 900px){ .container{ grid-template-columns: 1fr; } }

    .card { background:var(--card); border:1px solid var(--soft); border-radius:14px; padding:14px; box-shadow:0 6px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .row > * { margin:2px 0 }
    textarea { width:100%; min-height:200px; resize:vertical; background:#0f1623; color:var(--text); border:1px solid var(--outline); border-radius:10px; padding:10px; }
    button,.btn { border:1px solid var(--outline); background:#0f1623; color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer; min-height:44px }
    button:hover { border-color:var(--accent) }
    button:disabled{ opacity:.5; cursor:not-allowed; border-color:var(--outline) }
    .btn-ghost { background:transparent }
    .btn-ok { border-color: rgba(34,197,94,.4) }
    .btn-bad { border-color: rgba(239,68,68,.4) }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid var(--outline); }
    label { color:var(--muted); font-size:12px }

    .grid { display:grid; gap:10px; }

    .divider { height:1px; background:var(--soft); margin:10px 0 }

    .sentence-list { min-height:180px; display:grid; gap:8px; }

    /* --- Card layout with grid areas --- */
    .card-sentence { 
      display:grid; 
      grid-template-columns:auto 1fr auto; 
      grid-template-rows:auto auto; 
      grid-template-areas:
        "drag text counts"
        "drag bar  bar";
      gap:8px; align-items:center; padding:14px; border-radius:12px; border:1px solid var(--outline); background:#0d1420; 
    }
    .drag { grid-area: drag; font-size:16px; opacity:.7; cursor:grab; user-select:none }
    .text { grid-area: text; white-space:pre-wrap; }
    .counts { grid-area: counts; display:flex; gap:8px; align-items:center; font-variant-numeric: tabular-nums; }
    .counts .ok { color:var(--ok) }
    .counts .bad { color:var(--bad) }
    .counts button{ padding:10px 14px; min-width:44px; min-height:44px; font-size:16px }
    .progress { grid-area: bar; height:4px; border-radius:999px; background:#0b1220; overflow:hidden }
    .progress > i { display:block; height:100%; background: linear-gradient(90deg, var(--ok), #10b981); width:0% }

    .focused { outline:2px solid var(--accent); }
    .struggling { box-shadow: 0 0 0 1px rgba(239,68,68,.35) inset; }
    .ghost { opacity:.5 }

    .ta-ping { outline:2px solid var(--accent); transition: outline-color .6s ease; }

    details.learned { border:1px dashed var(--outline); border-radius:12px; padding:8px 10px; }
    details.learned summary { cursor:pointer; color:var(--muted) }

    .muted { color:var(--muted) }
    .spacer { flex:1 }
    .small { font-size:12px }
    .hint { color:var(--muted); font-size:11px }
    .kbd { border:1px solid var(--outline); border-bottom-width:2px; background:#0c1422; padding:0 6px; border-radius:6px; }

    .badge { font-size:11px; padding:2px 8px; border:1px solid var(--outline); border-radius:999px; color:var(--muted); }

    /* Prevent scroll-jank during a touch drag */
    .drag-active { touch-action: none; }

    /* --- Mobile stacking: put ✅/❌ below the text, hide drag handle --- */
    @media (max-width:600px){ 
      body{ font-size:16px; line-height:1.5 }
      textarea{ min-height:220px }
      .card-sentence{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        grid-template-areas:
          "text"
          "counts"
          "bar";
      }
      .drag{ display:none; }
      .counts{ justify-content:flex-start; }
      .counts button { padding:12px 16px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Memoriser</h1>
    <p>Import sentences under a label; practice by cut (3/2/1) and optional substitution (Off/30/50/90). ✅ auto-hides; tap a card to highlight in the textarea.</p>
    <p class="small muted" id="storageNote"></p>
  </header>

  <main class="container">
    <section class="card" id="inputCard">
      <!-- TOP: New Label UX: dropdown + New Label; inline input appears only when creating -->
      <div class="row" id="labelRow">
        <div class="pill" id="labelInputWrap" style="display:none">
          <label for="labelInput">New label</label>
          <input id="labelInput" type="text" placeholder="e.g., Genesis 1" style="background:transparent;color:var(--text);border:0;outline:none;min-width:160px">
          <button id="btnCancelNew" class="btn-ghost">Cancel</button>
        </div>
        <div class="pill" id="labelDropdownWrap">
          <label for="labelFilter">Practice label</label>
          <select id="labelFilter">
            <option value="" disabled selected>Select a label</option>
          </select>
        </div>
        <button id="btnNewLabel">New Label</button>
        <button id="btnGenerate" disabled>Generate</button>
      </div>

      <div class="grid" style="gap:10px;margin-top:8px">
        <label for="text">Paste text for the selected label</label>
        <textarea id="text" placeholder="Paste the text you want to memorise..."></textarea>
      </div>

      <div class="divider"></div>

      <!-- BELOW TEXTAREA: configuration strip -->
      <div class="row" style="row-gap:8px">
        <span class="pill">Cut:
          <label><input type="radio" name="cut" value="3" checked> 3</label>
          <label><input type="radio" name="cut" value="2"> 2</label>
          <label><input type="radio" name="cut" value="1"> 1</label>
        </span>
        <span class="pill">Substitute:
          <label><input type="radio" name="sub" value="0" checked> Off</label>
          <label><input type="radio" name="sub" value="30"> 30%</label>
          <label><input type="radio" name="sub" value="50"> 50%</label>
          <label><input type="radio" name="sub" value="90"> 90%</label>
        </span>
        <button id="btnScramble">Scramble</button>
        <button id="btnResetOrder" class="btn-ghost">Reset order</button>
        <div class="spacer"></div>
        <span class="pill">Struggle ≥ <input id="struggleN" type="number" min="1" value="1" style="width:54px; background:transparent; color:var(--text); border:0; text-align:center"></span>
        <label><input type="checkbox" id="toggleStruggle"> Show only struggling</label>
      </div>

      <div class="row small">
        <button id="btnCheckOrder" class="btn-ghost">Check order</button>
        <button id="btnResetCounts" class="btn-ghost">Reset counts</button>
        <button id="btnUnhideAll" class="btn-ghost">Unhide all</button>
        <button id="btnClearSession" class="btn-ghost">Clear session</button>
        <button id="btnExportCSV" class="btn-ghost">Copy progress (CSV)</button>
        <span class="spacer"></span>
        <span class="hint">Shortcuts: <span class="kbd">Enter</span>=✅ <span class="kbd">Backspace</span>=❌ <span class="kbd">↑/↓</span>=focus <span class="kbd">S</span>=scramble <span class="kbd">R</span>=reset</span>
      </div>
    </section>

    <section class="card" id="practiceCard">
      <div class="row" style="margin-bottom:6px">
        <strong>Practice</strong>
        <span class="muted small" id="cutNote">(Best with cut = 1)</span>
        <div class="spacer"></div>
        <button id="btnUndo" class="btn-ghost" title="Undo last">↶ Undo</button>
      </div>
      <div id="sentences" class="sentence-list" aria-live="polite"></div>
      <div id="emptyState" class="muted" style="display:none; padding:8px">Choose a label above or import sentences to begin.</div>
      <details class="learned" id="learnedPanel" open>
        <summary>Learned (<span id="learnedCount">0</span>)</summary>
        <div id="learnedList" class="sentence-list" style="margin-top:8px"></div>
      </details>
    </section>
  </main>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
  // Telegram theme + setup (no optional chaining for older webviews)
  (function(){
    var W = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
    if(!W) return;
    try{ W.ready(); W.expand(); }catch(e){}
    try{
      var isDark = (W.colorScheme === 'dark');
      document.documentElement.classList.toggle('tg-dark', isDark);
      if(W.setHeaderColor) W.setHeaderColor(isDark ? '#0b0f14' : '#ffffff');
      if(W.setBottomBarColor) W.setBottomBarColor('#ffffff');
    }catch(e){}
    try{ document.body.style.background = W.backgroundColor || getComputedStyle(document.body).backgroundColor; }catch(e){}
  })();
  </script>

  <script>
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));

  // --- Storage layer: CloudStorage when possible, else localStorage ---
  const TG = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
  const TG_VER = (function(){
    var v = 0; try { v = parseFloat((TG && (TG.version || TG.platformVersion)) || '0'); } catch(e) {}
    return isNaN(v) ? 0 : v;
  })();
  // Guard: only consider CloudStorage usable on recent versions
  const CS = (TG && TG.CloudStorage && TG_VER >= 6.9) ? TG.CloudStorage : null;
  const KEY_BASE = 'm:v7';
  const CHUNK = 3500;

  const storage = {
    async saveState(obj){
      const json = JSON.stringify(obj);
      if(!CS){ try{ localStorage.setItem(KEY_BASE, json); }catch(e){} return true; }
      try{
        const parts = Math.ceil(json.length / CHUNK);
        await new Promise(res=> { try{ CS.setItem(KEY_BASE+':index', String(parts), ()=>res(true)); } catch(e){ res(false); } });
        const promises = [];
        for(let i=0;i<parts;i++){
          const slice = json.slice(i*CHUNK, (i+1)*CHUNK);
          promises.push(new Promise(res=> { try{ CS.setItem(KEY_BASE+':'+i, slice, ()=>res(true)); } catch(e){ res(false); } }));
        }
        await Promise.all(promises);
        try{
          await new Promise(res=> { try{ CS.getKeys(function(keys){
            (keys||[]).filter(function(k){ return k.indexOf(KEY_BASE+':')===0 && k.indexOf(':index')===-1 && Number(k.split(':').pop())>=parts; })
              .forEach(function(k){ try{ CS.removeItem(k, function(){}); }catch(e){} });
            res(true);
          }); } catch(e){ res(false); } });
        }catch(e){}
        return true;
      }catch(err){
        try{ localStorage.setItem(KEY_BASE, json); }catch(e){}
        return true;
      }
    },
    async loadState(){
      if(!CS){ try{ var raw = localStorage.getItem(KEY_BASE); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
      try{
        const idxStr = await new Promise(res=> { try{ CS.getItem(KEY_BASE+':index', v=>res(v)); } catch(e){ res(null); } });
        if(!idxStr){ return null; }
        const parts = parseInt(idxStr,10) || 0; if(!parts) return null;
        const chunks = [];
        for(let i=0;i<parts;i++){
          const c = await new Promise(res=> { try{ CS.getItem(KEY_BASE+':'+i, v=>res(v||'')); } catch(e){ res(''); } });
          chunks.push(c);
        }
        try{ return JSON.parse(chunks.join('')); }catch(e){ return null; }
      }catch(err){
        try{ var raw2 = localStorage.getItem(KEY_BASE); return raw2? JSON.parse(raw2): null; }catch(e){ return null; }
      }
    },
    async clearState(){
      if(!CS){ try{ localStorage.removeItem(KEY_BASE); }catch(e){} return true; }
      try{
        const keys = await new Promise(res=> { try{ CS.getKeys(k=>res(k||[])); } catch(e){ res([]); } });
        const targets = keys.filter(k=> k===KEY_BASE || k.indexOf(KEY_BASE+':')===0);
        await Promise.all(targets.map(k=> new Promise(res=> { try{ CS.removeItem(k, ()=>res(true)); } catch(e){ res(true); } })));
        return true;
      }catch(err){ try{ localStorage.removeItem(KEY_BASE); }catch(e){} return true; }
    }
  };

  // hashing to make substitution deterministic per sentence/label
  function hash32(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h, 16777619);} return h>>>0; }
  function shouldMask(seed, wordIndex, pct){ if(pct<=0) return false; const h = hash32(seed+'#'+wordIndex); return (h % 100) < pct; }

  function splitSentences(text){
    const norm = text.trim().replace(/\r\n?/g, "\n");
    const withBreaks = norm.replace(/([.!?])\s+/g, '$1\n');
    return withBreaks.split(/\n+/).map(s=>s.trim()).filter(Boolean);
  }

  function applyCutAndSub(sentence, cutN, subPct, seed){
    if(!cutN) return sentence; let k=0;
    return sentence.replace(/([A-Za-zÀ-ÖØ-öø-ÿ]+(?:'[A-Za-zÀ-ÖØ-öø-ÿ]+)*)([^\sA-Za-zÀ-ÖØ-öÿ]*)/g, function(full, w, t){
      var cut = (w.length<=cutN? w : w.slice(0, cutN));
      if(subPct>0 && shouldMask(seed, k++, subPct)) cut = '_';
      return cut + t;
    });
  }

  // Data model
  let state = {
    sentences:[], labels:[], sentenceLabel:[], order:[], learned:new Set(), progress:{},
    cut:3, subPct:0, struggleOnly:false, struggleN:1, selectedLabel:'', newLabelMode:false, undoStack:[],
  };

  async function persist(){
    const payload = {
      sentences: state.sentences,
      labels: state.labels,
      sentenceLabel: state.sentenceLabel,
      order: state.order,
      learned: Array.from(state.learned),
      progress: state.progress,
      cut: state.cut,
      subPct: state.subPct,
      struggleOnly: state.struggleOnly,
      struggleN: state.struggleN,
      selectedLabel: state.selectedLabel,
    };
    storage.saveState(payload);
  }

  async function load(){
    const p = await storage.loadState(); if(!p) return;
    try{
      state.sentences = p.sentences||[];
      state.labels = p.labels||[];
      state.sentenceLabel = p.sentenceLabel||[];
      state.order = Array.isArray(p.order)? p.order : state.sentences.map(function(_,i){return i;});
      state.learned = new Set(p.learned||[]);
      state.progress = p.progress||{};
      state.cut = [1,2,3].indexOf(p.cut)>=0? p.cut:3;
      state.subPct = [0,30,50,90].indexOf(p.subPct)>=0? p.subPct:0;
      state.struggleOnly = !!p.struggleOnly;
      state.struggleN = (Number.isFinite && Number.isFinite(p.struggleN))? p.struggleN:1;
      state.selectedLabel = p.selectedLabel || '';
    }catch(e){ console.warn('load failed', e); }
  }

  function ensureLabel(name){ if(!name) return; if(state.labels.indexOf(name)===-1) state.labels.push(name); buildLabelDropdown(); }

  function buildLabelDropdown(){
    const sel = $('#labelFilter');
    const prev = state.selectedLabel;
    sel.innerHTML = (state.labels.length ? '' : '<option value="" disabled selected>Select a label</option>') + state.labels.map(function(L){return '<option value="'+L.replace(/\"/g,'&quot;')+'">'+L+'</option>';}).join('');
    sel.value = (prev && state.labels.indexOf(prev)>=0) ? prev : (state.labels[0]||'');
    state.selectedLabel = sel.value || '';
  }

  function populateTextareaForLabel(label){
    const ta = $('#text');
    if(!label){ ta.value=''; return; }
    const parts = state.sentences.filter(function(_,i){ return state.sentenceLabel[i]===label; });
    ta.value = parts.join('\n');
  }

  function showLabelSourceAndSelectSentence(idx){
    const label = state.sentenceLabel[idx];
    const indices = state.sentences.map(function(_,i){return i;}).filter(function(i){ return state.sentenceLabel[i]===label; });
    const parts = indices.map(function(i){ return state.sentences[i]; });
    const sep = '\n';
    const source = parts.join(sep);
    const ta = $('#text');
    ta.value = source;
    const k = indices.indexOf(idx);
    let start = 0; for(let i=0;i<k;i++){ start += parts[i].length + sep.length; }
    const end = start + parts[k].length;
    ta.focus(); if(ta.setSelectionRange) ta.setSelectionRange(start,end); else { ta.selectionStart=start; ta.selectionEnd=end; }
    ta.classList.add('ta-ping'); setTimeout(function(){ ta.classList.remove('ta-ping'); }, 600);
    if(/Mobi|Android/i.test(navigator.userAgent)){ ta.blur(); ta.focus(); }
  }

  function displaySentence(idx){
    const label = state.sentenceLabel[idx] || '';
    const seed = label+'|'+idx+'|'+state.subPct;
    const text = applyCutAndSub(state.sentences[idx], state.cut, state.subPct, seed);
    const prog = state.progress[idx] || {ok:0,bad:0};
    const total = prog.ok + prog.bad; const ratio = total? Math.round((prog.ok/total)*100):0;
    const card = document.createElement('div'); card.className='card-sentence'; card.draggable=true; card.dataset.idx=idx;
    const drag = document.createElement('div'); drag.className='drag'; drag.textContent='⋮⋮';
    const txt = document.createElement('div'); txt.className='text'; txt.textContent = text;
    const counts = document.createElement('div'); counts.className='counts';
    counts.innerHTML = '<span class="badge">'+(label||'Label')+'</span> <button class="btn btn-ok" data-act="ok" title="Mark correct">✅</button><span class="ok">('+(prog.ok)+')</span><button class="btn btn-bad" data-act="bad" title="Mark incorrect">❌</button><span class="bad">('+(prog.bad)+')</span>';
    const bar = document.createElement('div'); bar.className='progress'; bar.innerHTML = '<i style="width:'+ratio+'%"></i>';

    card.appendChild(drag); card.appendChild(txt); card.appendChild(counts); card.appendChild(bar);

    if((state.progress[idx] && state.progress[idx].bad || 0) >= state.struggleN){ card.classList.add('struggling'); }

    counts.addEventListener('click', function(e){ const btn=e.target.closest('button'); if(!btn) return; const act=btn.getAttribute('data-act'); if(!act) return; if(act==='ok') markOk(idx); if(act==='bad') markBad(idx); });
    card.addEventListener('click', function(e){ if(e.target.closest('button')||e.target.closest('.counts')) return; showLabelSourceAndSelectSentence(idx); });
    card.tabIndex=0; card.addEventListener('focus', function(){ $$('.card-sentence').forEach(function(x){x.classList.remove('focused');}); card.classList.add('focused'); });

    // Desktop DnD
    card.addEventListener('dragstart', function(e){ dragSrcIdx = idx; card.classList.add('ghost'); e.dataTransfer.effectAllowed='move'; });
    card.addEventListener('dragend', function(){ card.classList.remove('ghost'); });
    card.addEventListener('dragover', function(e){ e.preventDefault(); e.dataTransfer.dropEffect='move'; });
    card.addEventListener('drop', function(e){ e.preventDefault(); const from = dragSrcIdx; const to = state.order.indexOf(idx); moveCardByPosition(from, to); });

    // Touch reorder (long-press, pointer capture, auto-scroll)
    card.addEventListener('pointerdown', function(ev){
      if (ev.pointerType !== 'touch') return;
      if (ev.target.closest('button') || ev.target.closest('.counts')) return;
      var pressTimer = null; var startX = ev.clientX; var startY = ev.clientY; var container = $('#sentences');
      pressTimer = setTimeout(function(){ beginDrag(ev); }, 200);
      function cancelPress(){ clearTimeout(pressTimer); pressTimer=null; window.removeEventListener('pointermove', maybeCancel); window.removeEventListener('pointerup', cancelPress, {once:true}); }
      function maybeCancel(moveEv){ if (Math.abs(moveEv.clientY - startY) > 6 || Math.abs(moveEv.clientX - startX) > 6) cancelPress(); }
      window.addEventListener('pointermove', maybeCancel, { passive: true });
      window.addEventListener('pointerup', cancelPress, { once: true });
      function beginDrag(startEv){ if (navigator.vibrate) { try { navigator.vibrate(10); } catch (e){} }
        document.body.classList.add('drag-active'); card.classList.add('dragging'); if(card.setPointerCapture) card.setPointerCapture(startEv.pointerId);
        const cardRect = card.getBoundingClientRect();
        const ghost = card.cloneNode(true); Object.assign(ghost.style, { position:'fixed', left: cardRect.left+'px', top: cardRect.top+'px', width: cardRect.width+'px', pointerEvents:'none', opacity:'0.85', transform:'translate3d(0,0,0)', zIndex:1000 }); document.body.appendChild(ghost);
        const placeholder = document.createElement('div'); placeholder.className='card-sentence'; placeholder.style.height=card.offsetHeight+'px'; placeholder.style.border='1px dashed var(--outline)'; card.style.visibility='hidden'; card.parentNode.insertBefore(placeholder, card.nextSibling);
        var scrollRAF=null; function autoScroll(y){ var edge=60, speed=12, viewH=window.innerHeight; var dy=0; if(y < edge) dy=-speed; else if(y > viewH-edge) dy=speed; if(dy===0){ if(scrollRAF) cancelAnimationFrame(scrollRAF); scrollRAF=null; return; } var step=function(){ window.scrollBy(0, dy); scrollRAF=requestAnimationFrame(step); }; if(!scrollRAF) scrollRAF=requestAnimationFrame(step); }
        function onMove(e){ e.preventDefault(); const dy=e.clientY - startY; ghost.style.transform = 'translate3d(0, '+dy+'px, 0)'; autoScroll(e.clientY); const centerY = ghost.getBoundingClientRect().top + ghost.offsetHeight/2; const items = Array.from(container.children); let newPos = 0; for(let i=0;i<items.length;i++){ const r = items[i].getBoundingClientRect(); if(centerY > r.top + r.height/2) newPos = i+1; } newPos=Math.min(newPos, items.length-1); if(items[newPos]!==placeholder){ container.insertBefore(placeholder, items[newPos]); } }
        function onUp(){ if(scrollRAF) cancelAnimationFrame(scrollRAF); document.body.classList.remove('drag-active'); card.classList.remove('dragging'); ghost.remove(); const items = Array.from(container.children); const newPos = items.indexOf(placeholder); placeholder.replaceWith(card); card.style.visibility=''; window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); moveCardByPosition(idx, newPos); }
        window.addEventListener('pointermove', onMove, { passive: false }); window.addEventListener('pointerup', onUp, { once: true }); }
    });

    return card;
  }

  function render(){
    const list=$('#sentences'); list.innerHTML=''; const learnedList=$('#learnedList'); learnedList.innerHTML='';
    const filter=state.selectedLabel;
    const visibleIdxs=state.order.filter(function(i){ return filter && !state.learned.has(i) && state.sentenceLabel[i]===filter; });
    const learnedIdxs=state.order.filter(function(i){ return filter && state.learned.has(i) && state.sentenceLabel[i]===filter; });

    let any=false; for(const i of visibleIdxs){ if(state.struggleOnly && ((state.progress[i] && state.progress[i].bad)||0) < state.struggleN) continue; any=true; list.appendChild(displaySentence(i)); }
    $('#emptyState').style.display = any? 'none':'block';
    for(const i of learnedIdxs){ learnedList.appendChild(renderLearned(i)); }
    $('#learnedCount').textContent = learnedIdxs.length; $('#cutNote').textContent = state.cut===1? '(Progress mode)':'(Progress best at cut = 1)';
    buildLabelDropdown();
    persist();
  }

  function renderLearned(idx){ const label=state.sentenceLabel[idx]||''; const wrap=document.createElement('div'); wrap.className='card-sentence'; wrap.style.opacity=.85; const t=document.createElement('div'); t.className='text'; t.textContent=applyCutAndSub(state.sentences[idx], state.cut, state.subPct, label+'|'+idx+'|'+state.subPct); const counts=document.createElement('div'); counts.className='counts'; const p=state.progress[idx]||{ok:0,bad:0}; counts.innerHTML='<span class="badge">'+(label||'Label')+'</span> <span class="ok">✅('+(p.ok)+')</span><span class="bad">❌('+(p.bad)+')</span>'; const unhide=document.createElement('button'); unhide.textContent='Unhide'; unhide.className='btn btn-ghost'; unhide.addEventListener('click', function(){ state.learned.delete(idx); render(); }); wrap.appendChild(document.createTextNode('✔')); wrap.appendChild(t); wrap.appendChild(counts); wrap.appendChild(unhide); const bar=document.createElement('div'); bar.className='progress'; var pct = (p.ok + p.bad) ? (p.ok/(p.ok+p.bad))*100 : 0; bar.innerHTML='<i style="width:'+pct+'%"></i>'; wrap.appendChild(bar); wrap.addEventListener('click', function(e){ if(e.target.closest('button')) return; showLabelSourceAndSelectSentence(idx); }); return wrap; }

  // Actions
  let dragSrcIdx=null;
  function moveCardByPosition(fromSentenceIdx, toPosition){ const curPos=state.order.indexOf(fromSentenceIdx); if(curPos<0||toPosition<0) return; const arr=state.order.slice(); arr.splice(curPos,1); arr.splice(toPosition,0,fromSentenceIdx); state.order=arr; render(); }
  function markOk(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.ok++; state.learned.add(idx); render(); }
  function markBad(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.bad++; render(); }
  function resetOrder(){ state.order=state.sentences.map(function(_,i){return i;}); render(); }
  function resetCounts(){ state.progress={}; render(); }
  async function unhideAll(){ state.learned=new Set(); render(); }
  async function clearSession(){ await storage.clearState(); state={ sentences:[], labels:[], sentenceLabel:[], order:[], learned:new Set(), progress:{}, cut:3, subPct:0, struggleOnly:false, struggleN:1, selectedLabel:'', newLabelMode:false, undoStack:[] }; buildLabelDropdown(); populateTextareaForLabel(''); render(); }
  function checkOrder(){ const cards=$$('#sentences .card-sentence'); cards.forEach(function(card, pos){ const idx=Number(card.dataset.idx); const ok=idx===pos; card.style.outline = ok? '2px solid rgba(34,197,94,.6)' : '2px solid rgba(239,68,68,.4)'; }); setTimeout(function(){ cards.forEach(function(c){ c.style.outline=''; }); }, 1200); }
  function copyCSV(){ const rows=[['index','sentence','label','cut','subPct','ok','bad','learned']]; state.sentences.forEach(function(s,i){ const p=state.progress[i]||{ok:0,bad:0}; rows.push([i, s.replace(/\n/g,' '), state.sentenceLabel[i]||'', state.cut, state.subPct, p.ok, p.bad, state.learned.has(i)?1:0]); }); const csv=rows.map(function(r){return r.map(function(cell){ return '"'+String(cell).replace(/\"/g,'\"\"')+'"'; }).join(',');}).join('\n'); if(navigator.clipboard && window.isSecureContext){ navigator.clipboard.writeText(csv).then(function(){ alert('Progress copied to clipboard as CSV.'); }).catch(fallback);} else { fallback(); } function fallback(){ const ta=document.createElement('textarea'); ta.value=csv; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); alert('Progress copied to clipboard as CSV.'); }catch(e){ alert('Copy failed. Select text manually.'); } ta.remove(); } }

  // Import flow (Generate saves; New Label just toggles UI)
  $('#btnGenerate').addEventListener('click', function(){
    var isNew = !!state.newLabelMode;
    var label = isNew ? (($('#labelInput').value)||'').trim() : (($('#labelFilter').value)||'').trim();
    var t = (($('#text').value)||'').trim();
    if(!label){ alert('Please enter a label.'); return; }
    if(!t){ alert('Please paste some text.'); return; }
    var parts = splitSentences(t);
    if(!parts.length){ alert('No sentences found.'); return; }
    ensureLabel(label);
    var baseLen=state.sentences.length;
    for(var i=0;i<parts.length;i++){ state.sentences.push(parts[i]); state.sentenceLabel.push(label); }
    state.order = state.order.concat(parts.map(function(_,i){return baseLen + i;}));
    state.selectedLabel = label;
    buildLabelDropdown();
    render();
    populateTextareaForLabel(label);
    if(isNew){ setNewLabelMode(false); $('#labelInput').value=''; }
    updateGenerateEnabled();
  });

  // Controls
  $$('#inputCard input[name="cut"]').forEach(function(r){ r.addEventListener('change', function(){ state.cut=Number(document.querySelector('input[name="cut"]:checked').value); render(); }); });
  $$('#inputCard input[name="sub"]').forEach(function(r){ r.addEventListener('change', function(){ state.subPct=Number(document.querySelector('input[name="sub"]:checked').value); render(); }); });
  $('#btnScramble').addEventListener('click', function(){ const arr=state.order.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp; } state.order=arr; render(); });
  $('#btnResetOrder').addEventListener('click', resetOrder);
  $('#btnResetCounts').addEventListener('click', resetCounts);
  $('#btnUnhideAll').addEventListener('click', unhideAll);
  $('#btnClearSession').addEventListener('click', clearSession);
  $('#btnCheckOrder').addEventListener('click', checkOrder);
  $('#btnExportCSV').addEventListener('click', copyCSV);
  $('#labelFilter').addEventListener('change', function(e){ state.selectedLabel=e.target.value; render(); populateTextareaForLabel(state.selectedLabel); updateGenerateEnabled(); });
  $('#toggleStruggle').addEventListener('change', function(e){ state.struggleOnly=e.target.checked; render(); });
  $('#struggleN').addEventListener('change', function(e){ state.struggleN=clamp(parseInt(e.target.value||'1',10),1,999); render(); });

  // New Label UX
  function setNewLabelMode(on){
    state.newLabelMode = !!on;
    $('#labelInputWrap').style.display = on ? '' : 'none';
    $('#labelDropdownWrap').style.display = on ? 'none' : '';
    $('#btnCancelNew').style.display = on ? '' : 'none';
    $('#btnNewLabel').style.display = on ? 'none' : '';
    if(on){ $('#text').value=''; $('#labelInput').value=''; $('#labelInput').focus(); }
    else { populateTextareaForLabel(state.selectedLabel); }
    updateGenerateEnabled();
  }
  $('#btnNewLabel').addEventListener('click', function(){ setNewLabelMode(true); });
  $('#btnCancelNew').addEventListener('click', function(){ setNewLabelMode(false); });

  // Live-enable Generate as user types/selects
  $('#text').addEventListener('input', updateGenerateEnabled);
  document.addEventListener('input', function(e){ if(e.target && e.target.id==='labelInput'){ updateGenerateEnabled(); } });

  // Helpers to validate Generate availability
  function currentLabelCandidate(){ return state.newLabelMode ? (($('#labelInput').value)||'').trim() : (($('#labelFilter').value)||'').trim(); }
  function updateGenerateEnabled(){
    var hasLabel = !!currentLabelCandidate();
    var hasText = ((($('#text').value)||'').trim().length) > 0;
    var dis = !(hasLabel && hasText);
    var btn = $('#btnGenerate');
    if(btn){ btn.disabled = dis; btn.title = dis ? 'Enter a label and paste text' : ''; }
  }

  // Boot
  (async function boot(){
    await load();
    if([1,2,3].indexOf(state.cut)>=0){ var r = document.querySelector('input[name="cut"][value="'+state.cut+'"]'); if(r) r.checked=true; }
    if([0,30,50,90].indexOf(state.subPct)>=0){ var r2 = document.querySelector('input[name="sub"][value="'+state.subPct+'"]'); if(r2) r2.checked=true; }
    buildLabelDropdown();
    populateTextareaForLabel(state.selectedLabel);
    setNewLabelMode(false);
    render();
    updateGenerateEnabled();
    // Show storage mode to the user
    var note = document.getElementById('storageNote');
    if(note){
      var mode = CS ? ('Telegram CloudStorage (v'+TG_VER.toFixed(1)+')') : 'Local storage on this device';
      note.textContent = 'Storage: '+mode;
    }
  })();
  </script>
</body>
</html>