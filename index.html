<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memoriser — cut • substitute • scramble • drag</title>
  <link rel="icon" href="favicon.svg">
  <style>
    :root { --bg:#0b0f14; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --ok:#22c55e; --bad:#ef4444; --outline:#334155; --soft:#1f2937; }
    * { box-sizing: border-box; }
    body { margin:0; font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial,Apple Color Emoji,Segoe UI Emoji; background:var(--bg); color:var(--text); padding-bottom: env(safe-area-inset-bottom); overscroll-behavior-y: contain; }
    header { padding:16px 20px; border-bottom:1px solid var(--soft); position:sticky; top:0; background:linear-gradient(180deg, rgba(11,15,20,.97), rgba(11,15,20,.9)); backdrop-filter: blur(8px); z-index:5 }
    header h1 { margin:0 0 4px; font-weight:700; font-size:18px }
    header p { margin:0; color:var(--muted); font-size:12px }

    .container { display:grid; grid-template-columns: 1fr 1fr; gap:16px; padding:16px; }
    @media (max-width: 900px){ .container{ grid-template-columns: 1fr; } }

    .card { background:var(--card); border:1px solid var(--soft); border-radius:14px; padding:14px; box-shadow:0 6px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .row > * { margin:2px 0 }
    textarea { width:100%; min-height:200px; resize:vertical; background:#0f1623; color:var(--text); border:1px solid var(--outline); border-radius:10px; padding:10px; }
    button,.btn { border:1px solid var(--outline); background:#0f1623; color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer; min-height:44px }
    button:hover { border-color:var(--accent) }
    button:disabled{ opacity:.5; cursor:not-allowed; border-color:var(--outline) }
    .btn-ghost { background:transparent }
    .btn-ok { border-color: rgba(34,197,94,.4) }
    .btn-bad { border-color: rgba(239,68,68,.4) }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid var(--outline); }
    label { color:var(--muted); font-size:12px }

    .grid { display:grid; gap:10px; }

    .divider { height:1px; background:var(--soft); margin:10px 0 }

    .sentence-list { min-height:180px; display:grid; gap:8px; }

    .card-sentence { 
      display:grid; 
      grid-template-columns:auto 1fr auto; 
      grid-template-rows:auto auto; 
      grid-template-areas:
        "drag text counts"
        "drag bar  bar";
      gap:8px; align-items:center; padding:14px; border-radius:12px; border:1px solid var(--outline); background:#0d1420; 
    }
    .drag { grid-area: drag; font-size:16px; opacity:.7; cursor:grab; user-select:none }
    .text { grid-area: text; white-space:pre-wrap; }
    .counts { grid-area: counts; display:flex; gap:8px; align-items:center; font-variant-numeric: tabular-nums; }
    .counts .ok { color:var(--ok) }
    .counts .bad { color:var(--bad) }
    .counts button{ padding:10px 14px; min-width:44px; min-height:44px; font-size:16px }
    .progress { grid-area: bar; height:4px; border-radius:999px; background:#0b1220; overflow:hidden }
    .progress > i { display:block; height:100%; background: linear-gradient(90deg, var(--ok), #10b981); width:0% }

    .focused { outline:2px solid var(--accent); }
    .struggling { box-shadow: 0 0 0 1px rgba(239,68,68,.35) inset; }
    .ghost { opacity:.5 }

    .ta-ping { outline:2px solid var(--accent); transition: outline-color .6s ease; }

    details.learned { border:1px dashed var(--outline); border-radius:12px; padding:8px 10px; }
    details.learned summary { cursor:pointer; color:var(--muted) }

    .muted { color:var(--muted) }
    .spacer { flex:1 }
    .small { font-size:12px }
    .hint { color:var(--muted); font-size:11px }
    .kbd { border:1px solid var(--outline); border-bottom-width:2px; background:#0c1422; padding:0 6px; border-radius:6px; }

    .badge { font-size:11px; padding:2px 8px; border:1px solid var(--outline); border-radius:999px; color:var(--muted); }

    .drag-active { touch-action: none; }

    @media (max-width:600px){ 
      body{ font-size:16px; line-height:1.5 }
      textarea{ min-height:220px }
      .card-sentence{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        grid-template-areas:
          "text"
          "counts"
          "bar";
      }
      .drag{ display:none; }
      .counts{ justify-content:flex-start; }
      .counts button { padding:12px 16px; }
    }

    details.menu { position:relative; }
    details.menu > summary { list-style:none; cursor:pointer; }
    details.menu > summary::-webkit-details-marker{ display:none; }
    details.menu[open] > summary { outline: 2px solid var(--accent); border-radius:999px; }
    .menu-sheet { position:absolute; top:120%; left:0; background:#0f1623; border:1px solid var(--outline); border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.35); padding:6px; min-width:180px; z-index:10 }
    .menu-sheet button { width:100%; text-align:left; border-radius:8px; padding:8px 10px; }
    .menu-sheet button[disabled]{ opacity:.45 }
  </style>
</head>
<body>
  <header>
    <h1>Memoriser</h1>
    <p>Import sentences under a label; practice by cut (3/2/1) and optional substitution (Off/30/50/90). ✅ auto-hides; tap a card to highlight in the textarea.</p>
    <p class="small muted" id="storageNote"></p>
  </header>

  <main class="container">
    <section class="card" id="inputCard">
      <div class="row" id="labelRow">
        <div class="pill" id="labelInputWrap" style="display:none">
          <label for="labelInput">New label</label>
          <input id="labelInput" type="text" placeholder="e.g., Genesis 1" style="background:transparent;color:var(--text);border:0;outline:none;min-width:160px">
          <button id="btnCancelNew" class="btn-ghost">Cancel</button>
        </div>
        <div class="pill" id="labelDropdownWrap">
          <label for="labelFilter">Practice label</label>
          <select id="labelFilter">
            <option value="" disabled selected>Select a label</option>
          </select>
        </div>
        <details class="menu pill" id="manageMenu">
          <summary>Manage ▾</summary>
          <div class="menu-sheet" role="menu">
            <button type="button" data-act="new">New</button>
            <button type="button" data-act="rename" id="mRename" disabled>Rename</button>
            <button type="button" data-act="copy" id="mCopy">Copy Progress (CSV)</button>
            <button type="button" data-act="delete" id="mDelete" disabled>Delete</button>
          </div>
        </details>
        <button id="btnGenerate" disabled>Generate</button>
      </div>

      <div class="grid" style="gap:10px;margin-top:8px">
        <label for="text">Paste text for the selected label</label>
        <textarea id="text" placeholder="Paste the text you want to memorise..."></textarea>
      </div>

      <div class="divider"></div>

      <div class="row" style="row-gap:8px">
        <span class="pill">Cut:
          <label><input type="radio" name="cut" value="3" checked> 3</label>
          <label><input type="radio" name="cut" value="2"> 2</label>
          <label><input type="radio" name="cut" value="1"> 1</label>
        </span>
        <span class="pill">Substitute:
          <label><input type="radio" name="sub" value="0" checked> Off</label>
          <label><input type="radio" name="sub" value="30"> 30%</label>
          <label><input type="radio" name="sub" value="50"> 50%</label>
          <label><input type="radio" name="sub" value="90"> 90%</label>
        </span>
        <button id="btnScramble">Scramble</button>
        <button id="btnResetOrder" class="btn-ghost">Reset order</button>
        <div class="spacer"></div>
        <span class="pill">Struggle ≥ <input id="struggleN" type="number" min="1" value="1" style="width:54px; background:transparent; color:var(--text); border:0; text-align:center"></span>
        <label><input type="checkbox" id="toggleStruggle"> Show only struggling</label>
      </div>

      <div class="row small">
        <button id="btnCheckOrder" class="btn-ghost">Check order</button>
        <button id="btnResetCounts" class="btn-ghost">Reset counts</button>
        <button id="btnUnhideAll" class="btn-ghost">Unhide all</button>
        <span class="spacer"></span>
        <span class="hint">Shortcuts: <span class="kbd">Enter</span>=✅ <span class="kbd">Backspace</span>=❌ <span class="kbd">↑/↓</span>=focus <span class="kbd">S</span>=scramble <span class="kbd">R</span>=reset</span>
      </div>
    </section>

    <section class="card" id="practiceCard">
      <div class="row" style="margin-bottom:6px">
        <strong>Practice</strong>
        <span class="muted small" id="cutNote">(Best with cut = 1)</span>
        <div class="spacer"></div>
        <button id="btnUndo" class="btn-ghost" title="Undo last">↶ Undo</button>
      </div>
      <div id="sentences" class="sentence-list" aria-live="polite"></div>
      <div id="emptyState" class="muted" style="display:none; padding:8px">Choose a label above or import sentences to begin.</div>
      <details class="learned" id="learnedPanel" open>
        <summary>Learned (<span id="learnedCount">0</span>)</summary>
        <div id="learnedList" class="sentence-list" style="margin-top:8px"></div>
      </details>
    </section>
  </main>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
  (function(){
    var W = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
    if(!W) return;
    try{ W.ready(); W.expand(); }catch(e){}
    try{
      var isDark = (W.colorScheme === 'dark');
      document.documentElement.classList.toggle('tg-dark', isDark);
      if(W.setHeaderColor) W.setHeaderColor(isDark ? '#0b0f14' : '#ffffff');
      if(W.setBottomBarColor) W.setBottomBarColor('#ffffff');
    }catch(e){}
    try{ document.body.style.background = W.backgroundColor || getComputedStyle(document.body).backgroundColor; }catch(e){}
  })();
  </script>

  <script>
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));

  const TG = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
  const TG_VER = (function(){
    var v = 0; try { v = parseFloat((TG && (TG.version || TG.platformVersion)) || '0'); } catch(e) {}
    return isNaN(v) ? 0 : v;
  })();
  const CS = (TG && TG.CloudStorage && TG_VER >= 6.9) ? TG.CloudStorage : null;
  const KEY_BASE = 'memoriser:v1';
  const LEGACY_KEYS = ['mv7','memoriserv1','memoriser v1'];
  const CHUNK = 3500;

  const storage = {
    async saveState(obj){
      const json = JSON.stringify(obj);
      let lsOK = false, csOK = false;
      try { localStorage.setItem(KEY_BASE, json); lsOK = true; } catch(e){ console.warn('localStorage save failed', e); }
      if(CS){
        try{
          const parts = Math.ceil(json.length / CHUNK);
          await new Promise(res=> { try{ CS.setItem(KEY_BASE+':index', String(parts), ()=>res(true)); } catch(e){ res(false); } });
          const promises = [];
          for(let i=0;i<parts;i++){
            const slice = json.slice(i*CHUNK, (i+1)*CHUNK);
            promises.push(new Promise(res=> { try{ CS.setItem(KEY_BASE+':'+i, slice, ()=>res(true)); } catch(e){ res(false); } }));
          }
          await Promise.all(promises);
          csOK = true;
        }catch(err){ console.warn('CloudStorage save failed', err); }
      }
      try{ const note = document.getElementById('storageNote'); if(note){ note.textContent = 'Storage: '+(CS?('Telegram CloudStorage'+(csOK?' ✓':' ✕')):'Local storage')+'; Local '+(lsOK?'✓':'✕')+' at '+new Date().toLocaleTimeString(); } }catch(e){}
      return (lsOK || csOK);
    },
    async loadState(){
      // CloudStorage first
      if(CS){
        try{
          const idxStr = await new Promise(res=> { try{ CS.getItem(KEY_BASE+':index', v=>res(v)); } catch(e){ res(null); } });
          if(idxStr){
            const parts = parseInt(idxStr,10) || 0;
            const chunks = [];
            for(let i=0;i<parts;i++){
              const c = await new Promise(res=> { try{ CS.getItem(KEY_BASE+':'+i, v=>res(v||'')); } catch(e){ res(''); } });
              chunks.push(c);
            }
            try{ const parsed = JSON.parse(chunks.join('')); if(parsed) return parsed; }catch(e){ console.warn('CloudStorage parse failed', e); }
          }
        }catch(err){ console.warn('CloudStorage load failed', err); }
      }
      // LocalStorage current key
      try{
        const raw = localStorage.getItem(KEY_BASE);
        if(raw){ return JSON.parse(raw); }
      }catch(e){ console.warn('localStorage load (current) failed', e); }
      // LocalStorage legacy keys migration
      for(let i=0;i<LEGACY_KEYS.length;i++){
        try{
          const rawL = localStorage.getItem(LEGACY_KEYS[i]);
          if(rawL){
            try{
              const parsedL = JSON.parse(rawL);
              try{ localStorage.setItem(KEY_BASE, rawL); }catch(e){}
              return parsedL;
            }catch(parseErr){ console.warn('Legacy parse failed for', LEGACY_KEYS[i], parseErr); }
          }
        }catch(e){ /* continue */ }
      }
      return null;
    }
  };

  function hash32(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h, 16777619);} return h>>>0; }
  function shouldMask(seed, wordIndex, pct){ if(pct<=0) return false; const h = hash32(seed+'#'+wordIndex); return (h % 100) < pct; }


  function splitSentences(text){
    // No abbreviation guard (as requested).
    // 1) If there are blank lines, use them as hard separators.
    // 2) Otherwise collapse single \n to spaces and split on . ! ? …,
    //    EVEN when followed by quotes/brackets or nothing (end of string).
    const norm = String(text || '').replace(/\r\n?/g, '\n').trim();
    if (!norm) return [];

    if (/\n\s*\n/.test(norm)) {
        return norm.split(/\n\s*\n+/).map(s => s.trim()).filter(Boolean);
    }

    const collapsed = norm.replace(/\n+/g, ' ');
    // Add newline after punctuation (., !, ?, or ellipsis … \u2026)
    // Allow trailing ) " ' ] } then optional spaces, or end-of-string.
    const withBreaks = collapsed.replace(/([.!?\u2026])([)"'\]\}]*)\s*/g, '$1$2\n');
    return withBreaks.split(/\n+/).map(s => s.trim()).filter(Boolean);
    }


  function applyCutAndSub(sentence, cutN, subPct, seed){
    if(!cutN) return sentence; let k=0;
    return sentence.replace(/([A-Za-zÀ-ÖØ-öø-ÿ]+(?:'[A-Za-zÀ-ÖØ-öø-ÿ]+)*)([^\sA-Za-zÀ-ÖØ-öø-ÿ]*)/g, function(full, w, t){
      var cut = (w.length<=cutN? w : w.slice(0, cutN));
      if(subPct>0 && shouldMask(seed, k++, subPct)) cut = '_';
      return cut + t;
    });
  }

  let state = {
    sentences:[], labels:[], sentenceLabel:[], order:[], learned:new Set(), progress:{},
    cut:3, subPct:0, struggleOnly:false, struggleN:1, selectedLabel:'', newLabelMode:false, undoStack:[],
  };

  function snapshot(){
    return {
      sentences: state.sentences.slice(),
      labels: state.labels.slice(),
      sentenceLabel: state.sentenceLabel.slice(),
      order: state.order.slice(),
      learned: Array.from(state.learned),
      progress: JSON.parse(JSON.stringify(state.progress)),
      selectedLabel: state.selectedLabel
    };
  }
  function pushUndo(){ state.undoStack.push(snapshot()); }
  function applySnapshot(s){
    state.sentences = s.sentences.slice();
    state.labels = s.labels.slice();
    state.sentenceLabel = s.sentenceLabel.slice();
    state.order = s.order.slice();
    state.learned = new Set(s.learned);
    state.progress = JSON.parse(JSON.stringify(s.progress));
    state.selectedLabel = s.selectedLabel || '';
  }

  async function persist(){
    const payload = {
      sentences: state.sentences,
      labels: state.labels,
      sentenceLabel: state.sentenceLabel,
      order: state.order,
      learned: Array.from(state.learned),
      progress: state.progress,
      cut: state.cut,
      subPct: state.subPct,
      struggleOnly: state.struggleOnly,
      struggleN: state.struggleN,
      selectedLabel: state.selectedLabel,
    };
    storage.saveState(payload);
  }

  function renderLearned(i){
    const d=document.createElement('div'); d.className='card-sentence'; d.innerHTML='<div class="text">'+applyCutAndSub(state.sentences[i], state.cut, state.subPct, state.sentenceLabel[i]+'|'+i+'|'+state.subPct)+'</div><div class="progress"><i style="width:100%"></i></div>';
    return d;
  }

  function render(){
    const list=$('#sentences'); list.innerHTML=''; const learnedList=$('#learnedList'); learnedList.innerHTML='';
    const filter=state.selectedLabel;
    const visibleIdxs=state.order.filter(function(i){ return filter && !state.learned.has(i) && state.sentenceLabel[i]===filter; });
    const learnedIdxs=state.order.filter(function(i){ return filter && state.learned.has(i) && state.sentenceLabel[i]===filter; });

    let any=false; for(const i of visibleIdxs){ if(state.struggleOnly && ((state.progress[i] && state.progress[i].bad)||0) < state.struggleN) continue; any=true; list.appendChild(displaySentence(i)); }
    const empty = $('#emptyState');
    if(any){ empty.style.display='none'; }
    else {
      empty.style.display='block';
      empty.textContent = state.struggleOnly ? 'No cards match the current filter (Show only struggling). Try unchecking it or lowering the threshold.' : 'Choose a label above or import sentences to begin.';
      if(state.selectedLabel && state.struggleOnly){ state.struggleOnly=false; const cb=$('#toggleStruggle'); if(cb) cb.checked=false; setTimeout(render,0); }
    }

    for(const i of learnedIdxs){ learnedList.appendChild(renderLearned(i)); }
    $('#learnedCount').textContent = learnedIdxs.length; $('#cutNote').textContent = state.cut===1? '(Progress mode)':'(Progress best at cut = 1)';
    persist();
  }

  function ensureLabel(name){ if(!name) return; if(state.labels.indexOf(name)===-1) state.labels.push(name); buildLabelDropdown(); }

  function buildLabelDropdown(){
    const sel = $('#labelFilter');
    const prev = state.selectedLabel;
    sel.innerHTML = (state.labels.length ? '' : '<option value="" disabled selected>Select a label</option>') + state.labels.map(function(L){return '<option value="'+L.replace(/\"/g,'&quot;')+'">'+L+'</option>';}).join('');
    sel.value = (prev && state.labels.indexOf(prev)>=0) ? prev : (state.labels[0]||'');
    state.selectedLabel = sel.value || '';
    updateManageButtons();
  }

  function populateTextareaForLabel(label){
    const ta = $('#text');
    if(!label){ ta.value=''; return; }
    const parts = state.sentences.filter(function(_,i){ return state.sentenceLabel[i]===label; });
    ta.value = parts.join('\n');
  }

  function showLabelSourceAndSelectSentence(idx){
    const label = state.sentenceLabel[idx];
    const indices = state.sentences.map(function(_,i){return i;}).filter(function(i){ return state.sentenceLabel[i]===label; });
    const parts = indices.map(function(i){ return state.sentences[i]; });
    const sep = '\n';
    const source = parts.join(sep);
    const ta = $('#text');
    ta.value = source;
    const k = indices.indexOf(idx);
    let start = 0; for(let i=0;i<k;i++){ start += parts[i].length + sep.length; }
    const end = start + parts[k].length;
    ta.focus(); if(ta.setSelectionRange) ta.setSelectionRange(start,end); else { ta.selectionStart=start; ta.selectionEnd=end; }
    ta.classList.add('ta-ping'); setTimeout(function(){ ta.classList.remove('ta-ping'); }, 600);
    if(/Mobi|Android/i.test(navigator.userAgent)){ ta.blur(); ta.focus(); }
  }

  function updateManageButtons(){
    var has = !!state.selectedLabel;
    ['mRename','mDelete'].forEach(function(id){ var el=$('#'+id); if(el) el.disabled = !has; });
  }

  function renameLabel(oldName, newName){
    newName = (newName||'').trim(); if(!newName) return false;
    if(state.labels.indexOf(newName)>=0){ alert('Label "'+newName+'" already exists.'); return false; }
    pushUndo();
    var i = state.labels.indexOf(oldName); if(i>=0) state.labels[i] = newName;
    state.sentenceLabel = state.sentenceLabel.map(function(L){ return L===oldName ? newName : L; });
    if(state.selectedLabel===oldName) state.selectedLabel = newName;
    buildLabelDropdown();
    populateTextareaForLabel(state.selectedLabel);
    render();
    return true;
  }

  function deleteLabel(label){
    if(!label) return; const toRemove = []; for(let i=0;i<state.sentences.length;i++){ if(state.sentenceLabel[i]===label) toRemove.push(i); }
    if(!toRemove.length){ alert('Nothing to delete.'); return; }
    if(!confirm('Delete label "'+label+'" and its '+toRemove.length+' sentences? This can be undone.')) return;
    pushUndo();
    const toKeep = []; const map = {};
    for(let i=0;i<state.sentences.length;i++){ if(toRemove.indexOf(i)===-1){ map[i]=toKeep.length; toKeep.push(i); } }
    state.sentences = toKeep.map(function(i){ return state.sentences[i]; });
    state.sentenceLabel = toKeep.map(function(i){ return state.sentenceLabel[i]; });
    state.order = state.order.filter(function(i){ return toRemove.indexOf(i)===-1; }).map(function(i){ return map[i]; });
    const progNew = {}; for(const oldIdx in state.progress){ const oi=parseInt(oldIdx,10); if(toRemove.indexOf(oi)===-1){ progNew[ map[oi] ] = state.progress[oi]; } }
    state.progress = progNew;
    state.learned = new Set(Array.from(state.learned).filter(function(i){ return toRemove.indexOf(i)===-1; }).map(function(i){ return map[i]; }));
    state.labels = state.labels.filter(function(L){ return L!==label; });
    state.selectedLabel = state.labels[0] || '';
    buildLabelDropdown();
    populateTextareaForLabel(state.selectedLabel);
    render();
  }

  function displaySentence(idx){
    const label = state.sentenceLabel[idx] || '';
    const seed = label+'|'+idx+'|'+state.subPct;
    const text = applyCutAndSub(state.sentences[idx], state.cut, state.subPct, seed);
    const prog = state.progress[idx] || {ok:0,bad:0};
    const total = prog.ok + prog.bad; const ratio = total? Math.round((prog.ok/total)*100):0;
    const card = document.createElement('div'); card.className='card-sentence'; card.draggable=true; card.dataset.idx=idx;
    const drag = document.createElement('div'); drag.className='drag'; drag.textContent='⋮⋮';
    const txt = document.createElement('div'); txt.className='text'; txt.textContent = text;
    const counts = document.createElement('div'); counts.className='counts';
    counts.innerHTML = '<span class="badge">'+(label||'Label')+'</span> <button class="btn btn-ok" data-act="ok" title="Mark correct">✅</button><span class="ok">('+(prog.ok)+')</span><button class="btn btn-bad" data-act="bad" title="Mark incorrect">❌</button><span class="bad">('+(prog.bad)+')</span>';
    const bar = document.createElement('div'); bar.className='progress'; bar.innerHTML = '<i style="width:'+ratio+'%"></i>';

    card.appendChild(drag); card.appendChild(txt); card.appendChild(counts); card.appendChild(bar);

    if((state.progress[idx] && state.progress[idx].bad || 0) >= state.struggleN){ card.classList.add('struggling'); }

    counts.addEventListener('click', function(e){ const btn=e.target.closest('button'); if(!btn) return; const act=btn.getAttribute('data-act'); if(!act) return; if(act==='ok') markOk(idx); if(act==='bad') markBad(idx); });
    card.addEventListener('click', function(e){ if(e.target.closest('button')||e.target.closest('.counts')) return; showLabelSourceAndSelectSentence(idx); });
    card.tabIndex=0; card.addEventListener('focus', function(){ $$('.card-sentence').forEach(function(x){x.classList.remove('focused');}); card.classList.add('focused'); });

    card.addEventListener('dragstart', function(e){ dragSrcIdx = idx; card.classList.add('ghost'); e.dataTransfer.effectAllowed='move'; });
    card.addEventListener('dragend', function(){ card.classList.remove('ghost'); });
    card.addEventListener('dragover', function(e){ e.preventDefault(); e.dataTransfer.dropEffect='move'; });
    card.addEventListener('drop', function(e){ e.preventDefault(); const from = dragSrcIdx; const to = state.order.indexOf(idx); moveCardByPosition(from, to); });

    card.addEventListener('pointerdown', function(ev){
      if (ev.pointerType !== 'touch') return;
      if (ev.target.closest('button') || ev.target.closest('.counts')) return;
      var pressTimer = null; var startX = ev.clientX; var startY = ev.clientY; var container = $('#sentences');
      pressTimer = setTimeout(function(){ beginDrag(ev); }, 200);
      function cancelPress(){ clearTimeout(pressTimer); pressTimer=null; window.removeEventListener('pointermove', maybeCancel); window.removeEventListener('pointerup', cancelPress, {once:true}); }
      function maybeCancel(moveEv){ if (Math.abs(moveEv.clientY - startY) > 6 || Math.abs(moveEv.clientX - startX) > 6) cancelPress(); }
      window.addEventListener('pointermove', maybeCancel, { passive: true });
      window.addEventListener('pointerup', cancelPress, { once: true });
      function beginDrag(startEv){ if (navigator.vibrate) { try { navigator.vibrate(10); } catch (e){} }
        document.body.classList.add('drag-active'); card.classList.add('dragging'); if(card.setPointerCapture) card.setPointerCapture(startEv.pointerId);
        const cardRect = card.getBoundingClientRect();
        const ghost = card.cloneNode(true); Object.assign(ghost.style, { position:'fixed', left: cardRect.left+'px', top: cardRect.top+'px', width: cardRect.width+'px', pointerEvents:'none', opacity:'0.85', transform:'translate3d(0,0,0)', zIndex:1000 }); document.body.appendChild(ghost);
        const placeholder = document.createElement('div'); placeholder.className='card-sentence'; placeholder.style.height=card.offsetHeight+'px'; placeholder.style.border='1px dashed var(--outline)'; card.style.visibility='hidden'; card.parentNode.insertBefore(placeholder, card.nextSibling);
        var scrollRAF=null; function autoScroll(y){ var edge=60, speed=12, viewH=window.innerHeight; var dy=0; if(y < edge) dy=-speed; else if(y > viewH-edge) dy=speed; if(dy===0){ if(scrollRAF) cancelAnimationFrame(scrollRAF); scrollRAF=null; return; } var step=function(){ window.scrollBy(0, dy); scrollRAF=requestAnimationFrame(step); }; if(!scrollRAF) scrollRAF=requestAnimationFrame(step); }
        function onMove(e){ e.preventDefault(); const dy=e.clientY - startY; ghost.style.transform = 'translate3d(0, '+dy+'px, 0)'; autoScroll(e.clientY); const centerY = ghost.getBoundingClientRect().top + ghost.offsetHeight/2; const items = Array.from(container.children); let newPos = 0; for(let i=0;i<items.length;i++){ const r = items[i].getBoundingClientRect(); if(centerY > r.top + r.height/2) newPos = i+1; } newPos=Math.min(newPos, items.length-1); if(items[newPos]!==placeholder){ container.insertBefore(placeholder, items[newPos]); } }
        function onUp(){ if(scrollRAF) cancelAnimationFrame(scrollRAF); document.body.classList.remove('drag-active'); card.classList.remove('dragging'); ghost.remove(); const items = Array.from(container.children); const newPos = items.indexOf(placeholder); placeholder.replaceWith(card); card.style.visibility=''; window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); moveCardByPosition(idx, newPos); }
        window.addEventListener('pointermove', onMove, { passive: false }); window.addEventListener('pointerup', onUp, { once: true }); }
    });

    return card;
  }

  let dragSrcIdx=null;
  function moveCardByPosition(fromSentenceIdx, toPosition){ const curPos=state.order.indexOf(fromSentenceIdx); if(curPos<0||toPosition<0) return; const arr=state.order.slice(); arr.splice(curPos,1); arr.splice(toPosition,0,fromSentenceIdx); state.order=arr; render(); }
  function markOk(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.ok++; state.learned.add(idx); render(); }
  function markBad(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.bad++; render(); }
  function resetOrder(){ state.order=state.sentences.map(function(_,i){return i;}); render(); }
  function resetCounts(){ state.progress={}; render(); }
  async function unhideAll(){ state.learned=new Set(); render(); }




  function checkOrder() {
  // Expected = natural ascending index of the CURRENTLY VISIBLE subset
  // (selected label, not learned, and optional struggling filter).
  const expected = state.sentences.map((_, i) => i)
    .filter(i => state.selectedLabel && state.sentenceLabel[i] === state.selectedLabel && !state.learned.has(i))
    .filter(i => !state.struggleOnly || (((state.progress[i]?.bad) || 0) >= state.struggleN))
    .sort((a, b) => a - b);

  const cards = $$('#sentences .card-sentence');
  cards.forEach((card, pos) => {
    const idx = Number(card.dataset.idx);
    const ok = expected[pos] === idx;
    card.style.outline = ok
      ? '2px solid rgba(34,197,94,.6)'
      : '2px solid rgba(239,68,68,.4)';
  });
  setTimeout(() => { cards.forEach(c => { c.style.outline = ''; }); }, 1200);
}




  function copyCSV(){ const rows=[['index','sentence','label','cut','subPct','ok','bad','learned']]; state.sentences.forEach(function(s,i){ const p=state.progress[i]||{ok:0,bad:0}; rows.push([i, s.replace(/\n/g,' '), state.sentenceLabel[i]||'', state.cut, state.subPct, p.ok, p.bad, state.learned.has(i)?1:0]); }); const csv=rows.map(function(r){return r.map(function(cell){ return '"'+String(cell).replace(/\"/g,'\"\"')+'"'; }).join(',');}).join('\n'); if(navigator.clipboard && window.isSecureContext){ navigator.clipboard.writeText(csv).then(function(){ alert('Progress copied to clipboard as CSV.'); }).catch(fallback);} else { fallback(); } function fallback(){ const ta=document.createElement('textarea'); ta.value=csv; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); alert('Progress copied to clipboard as CSV.'); }catch(e){ alert('Copy failed. Select text manually.'); } ta.remove(); } }

  function currentLabelCandidate(){ return state.newLabelMode ? (($('#labelInput').value)||'').trim() : (($('#labelFilter').value)||'').trim(); }
  function updateGenerateEnabled(){
    var hasLabel = !!currentLabelCandidate();
    var hasText = ((($('#text').value)||'').trim().length) > 0;
    var dis = !(hasLabel && hasText);
    var btn = $('#btnGenerate');
    if(btn){ btn.disabled = dis; btn.title = dis ? 'Enter a label and paste text' : ''; }
  }

  $('#btnGenerate').addEventListener('click', function(){
    var isNew = !!state.newLabelMode;
    var label = currentLabelCandidate();
    var t = (($('#text').value)||'').trim();
    if(!label){ alert('Please enter a label.'); return; }
    if(!t){ alert('Please paste some text.'); return; }
    var parts = splitSentences(t);
    if(!parts.length){ alert('No sentences found.'); return; }

    if(isNew && state.labels.indexOf(label) !== -1){
      setNewLabelMode(false);
      state.selectedLabel = label;
      isNew = false;
    }

    if(isNew){
      ensureLabel(label);
      var baseNew = state.sentences.length;
      for(var i=0;i<parts.length;i++){ state.sentences.push(parts[i]); state.sentenceLabel.push(label); }
      state.order = state.order.concat(parts.map(function(_,i){return baseNew + i;}));
      state.selectedLabel = label;
      buildLabelDropdown();
      render();
      populateTextareaForLabel(label);
      setNewLabelMode(false);
      $('#labelInput').value='';
      updateGenerateEnabled();
      return;
    }

    var oldLabel = label;
    var toRemove = [];
    for(var j=0;j<state.sentences.length;j++){ if(state.sentenceLabel[j]===oldLabel) toRemove.push(j); }

    pushUndo();

    var toKeep = []; var map = {};
    for(var k=0;k<state.sentences.length;k++){ if(toRemove.indexOf(k)===-1){ map[k] = toKeep.length; toKeep.push(k); } }

    var keptSentences = toKeep.map(function(i){ return state.sentences[i]; });
    var keptLabels    = toKeep.map(function(i){ return state.sentenceLabel[i]; });

    state.order = state.order.filter(function(i){ return toRemove.indexOf(i)===-1; }).map(function(i){ return map[i]; });
    var progNew = {}; for(var key in state.progress){ if(Object.prototype.hasOwnProperty.call(state.progress,key)){ var oi=parseInt(key,10); if(toRemove.indexOf(oi)===-1){ progNew[ map[oi] ] = state.progress[key]; } } }
    state.progress = progNew;
    state.learned = new Set(Array.from(state.learned).filter(function(i){ return toRemove.indexOf(i)===-1; }).map(function(i){ return map[i]; }));

    var base = keptSentences.length;
    for(var p=0;p<parts.length;p++){ keptSentences.push(parts[p]); keptLabels.push(oldLabel); }

    state.sentences = keptSentences;
    state.sentenceLabel = keptLabels;
    state.order = state.order.concat(parts.map(function(_,i){ return base + i; }));

    state.selectedLabel = oldLabel;
    buildLabelDropdown();
    render();
    populateTextareaForLabel(oldLabel);
    updateGenerateEnabled();
    var practice = document.getElementById('practiceCard'); if(practice && practice.scrollIntoView){ practice.scrollIntoView({behavior:'smooth', block:'start'}); }
  });

  $$('#inputCard input[name="cut"]').forEach(function(r){ r.addEventListener('change', function(){ state.cut=Number(document.querySelector('input[name="cut"]:checked').value); render(); }); });
  $$('#inputCard input[name="sub"]').forEach(function(r){ r.addEventListener('change', function(){ state.subPct=Number(document.querySelector('input[name="sub"]:checked').value); render(); }); });
  $('#btnScramble').addEventListener('click', function(){ const arr=state.order.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); const tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp; } state.order=arr; render(); });
  $('#btnResetOrder').addEventListener('click', resetOrder);
  $('#btnResetCounts').addEventListener('click', resetCounts);
  $('#btnUnhideAll').addEventListener('click', unhideAll);
  $('#btnCheckOrder').addEventListener('click', checkOrder);
  $('#labelFilter').addEventListener('change', function(e){ state.selectedLabel=e.target.value; render(); populateTextareaForLabel(state.selectedLabel); updateGenerateEnabled(); updateManageButtons(); });
  $('#toggleStruggle').addEventListener('change', function(e){ state.struggleOnly=e.target.checked; render(); });
  $('#struggleN').addEventListener('change', function(e){ state.struggleN=clamp(parseInt(e.target.value||'1',10),1,999); render(); });

  $('#manageMenu').addEventListener('click', function(e){
    const btn = e.target.closest('button'); if(!btn) return;
    const act = btn.getAttribute('data-act');
    if(act==='new') { setNewLabelMode(true); }
    if(act==='rename'){
      if(!state.selectedLabel) return; const nn = prompt('Rename label \"'+state.selectedLabel+'\" to:'); if(nn && nn.trim()) renameLabel(state.selectedLabel, nn.trim());
    }
    if(act==='copy'){
      copyCSV();
    }
    if(act==='delete'){
      if(!state.selectedLabel) return; deleteLabel(state.selectedLabel);
    }
    document.getElementById('manageMenu').open = false;
  });

  function setNewLabelMode(on){
    state.newLabelMode = !!on;
    $('#labelInputWrap').style.display = on ? '' : 'none';
    $('#labelDropdownWrap').style.display = on ? 'none' : '';
    $('#btnCancelNew').style.display = on ? '' : 'none';
    if(on){ $('#text').value=''; $('#labelInput').value=''; $('#labelInput').focus(); }
    else { populateTextareaForLabel(state.selectedLabel); }
    updateGenerateEnabled();
  }
  $('#btnCancelNew').addEventListener('click', function(){ setNewLabelMode(false); });

  $('#btnUndo').addEventListener('click', function(){ const s=state.undoStack.pop(); if(!s){ alert('Nothing to undo.'); return; } applySnapshot(s); render(); populateTextareaForLabel(state.selectedLabel); updateManageButtons(); });

  $('#text').addEventListener('input', updateGenerateEnabled);
  document.addEventListener('input', function(e){ if(e.target && e.target.id==='labelInput'){ updateGenerateEnabled(); } });

  (async function boot(){
    const p = await storage.loadState();
    if(p){
      try{
        state.sentences = p.sentences||[];
        state.labels = p.labels||[];
        state.sentenceLabel = p.sentenceLabel||[];
        state.order = Array.isArray(p.order)? p.order : state.sentences.map(function(_,i){return i;});
        state.learned = new Set(p.learned||[]);
        state.progress = p.progress||{};
      }catch(e){ console.warn('load parse failed', e); }
    }
    if([1,2,3].indexOf((p&&p.cut)||state.cut)>=0){ state.cut = (p&&p.cut)||state.cut; var r = document.querySelector('input[name="cut"][value="'+state.cut+'"]'); if(r) r.checked=true; }
    if([0,30,50,90].indexOf((p&&p.subPct)||state.subPct)>=0){ state.subPct = (p&&p.subPct)||state.subPct; var r2 = document.querySelector('input[name="sub"][value="'+state.subPct+'"]'); if(r2) r2.checked=true; }
    state.struggleOnly = !!((p&&p.struggleOnly) || state.struggleOnly);
    state.struggleN = (p && Number.isFinite && Number.isFinite(p.struggleN))? p.struggleN: state.struggleN;
    state.selectedLabel = (p&&p.selectedLabel) || state.selectedLabel || '';

    buildLabelDropdown();
    populateTextareaForLabel(state.selectedLabel);
    setNewLabelMode(false);
    render();
    updateGenerateEnabled();
    var note = document.getElementById('storageNote');
    if(note){ var mode = CS ? ('Telegram CloudStorage (v'+TG_VER.toFixed(1)+')') : 'Local storage on this device'; note.textContent = 'Storage: '+mode; }
  })();
  </script>
</body>
</html>
