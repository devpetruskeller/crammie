<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512" fill="none">
    <!-- Background rounded square -->
    <rect x="32" y="32" width="448" height="448" rx="96" fill="#0b0f14"/>
    <rect x="32" y="32" width="448" height="448" rx="96" fill="url(#g)" opacity="0.4"/>

    <!-- Stylised M (for Crammie) -->
    <path d="M128 360V160h48l80 112 80-112h48v200h-48V246l-80 110-80-110v114h-48z" fill="#22d3ee"/>

    <!-- Accent dot (hinting at a bullet / sentence) -->
    <circle cx="392" cy="136" r="16" fill="#22c55e"/>

    <defs>
    <linearGradient id="g" x1="32" y1="32" x2="480" y2="480" gradientUnits="userSpaceOnUse">
    <stop stop-color="#111827"/>
    <stop offset="1" stop-color="#0b0f14"/>
    </linearGradient>
    </defs>
  </svg>



  
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crammie</title>
  <link rel="icon" href="favicon.svg">
  <style>
    :root { --bg:#0b0f14; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --ok:#22c55e; --bad:#ef4444; --outline:#334155; --soft:#1f2937; }
    * { box-sizing: border-box; }
    body { margin:0; font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial,Apple Color Emoji,Segoe UI Emoji; background:var(--bg); color:var(--text); }
    header { padding:16px 20px; border-bottom:1px solid var(--soft); position:sticky; top:0; background:linear-gradient(180deg, rgba(11,15,20,.97), rgba(11,15,20,.9)); backdrop-filter: blur(8px); z-index:5 }
    header h1 { margin:0 0 4px; font-weight:700; font-size:18px }
    header p { margin:0; color:var(--muted); font-size:12px }

    .container { display:grid; grid-template-columns: 1fr 1fr; gap:16px; padding:16px; }
    @media (max-width: 900px){ .container{ grid-template-columns: 1fr; } }

    .card { background:var(--card); border:1px solid var(--soft); border-radius:14px; padding:14px; box-shadow:0 6px 24px rgba(0,0,0,.25); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
    .row > * { margin:2px 0 }
    textarea { width:100%; min-height:200px; resize:vertical; background:#0f1623; color:var(--text); border:1px solid var(--outline); border-radius:10px; padding:10px; }
    button,.btn { border:1px solid var(--outline); background:#0f1623; color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer; min-height:44px }
    button:hover { border-color:var(--accent) }
    .btn-ghost { background:transparent }
    .btn-ok { border-color: rgba(34,197,94,.4) }
    .btn-bad { border-color: rgba(239,68,68,.4) }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid var(--outline); }
    label { color:var(--muted); font-size:12px }

    .grid { display:grid; gap:10px; }

    .divider { height:1px; background:var(--soft); margin:10px 0 }

    .sentence-list { min-height:180px; display:grid; gap:8px; }

    /* --- Card layout with grid areas --- */
    .card-sentence { 
      display:grid; 
      grid-template-columns:auto 1fr auto; 
      grid-template-rows:auto auto; 
      grid-template-areas:
        "drag text counts"
        "drag bar  bar";
      gap:8px; align-items:center; padding:14px; border-radius:12px; border:1px solid var(--outline); background:#0d1420; 
    }
    .drag { grid-area: drag; font-size:16px; opacity:.7; cursor:grab; user-select:none }
    .text { grid-area: text; white-space:pre-wrap; }
    .counts { grid-area: counts; display:flex; gap:8px; align-items:center; font-variant-numeric: tabular-nums; }
    .counts .ok { color:var(--ok) }
    .counts .bad { color:var(--bad) }
    .counts button{ padding:10px 14px; min-width:44px; min-height:44px; font-size:16px }
    .progress { grid-area: bar; height:4px; border-radius:999px; background:#0b1220; overflow:hidden }
    .progress > i { display:block; height:100%; background: linear-gradient(90deg, var(--ok), #10b981); width:0% }

    .focused { outline:2px solid var(--accent); }
    .struggling { box-shadow: 0 0 0 1px rgba(239,68,68,.35) inset; }
    .ghost { opacity:.5 }

    .ta-ping { outline:2px solid var(--accent); transition: outline-color .6s ease; }

    details.learned { border:1px dashed var(--outline); border-radius:12px; padding:8px 10px; }
    details.learned summary { cursor:pointer; color:var(--muted) }

    .muted { color:var(--muted) }
    .spacer { flex:1 }
    .small { font-size:12px }
    .hint { color:var(--muted); font-size:11px }
    .kbd { border:1px solid var(--outline); border-bottom-width:2px; background:#0c1422; padding:0 6px; border-radius:6px; }

    .moveBtns{ display:flex; gap:6px }
    .moveBtns button{ min-width:44px }

    .badge { font-size:11px; padding:2px 8px; border:1px solid var(--outline); border-radius:999px; color:var(--muted); }

    /* --- Mobile stacking: put ✅/❌ below the text, hide drag handle --- */
    @media (max-width:600px){ 
      body{ font-size:16px; line-height:1.5 }
      textarea{ min-height:220px }
      .card-sentence{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        grid-template-areas:
          "text"
          "counts"
          "bar";
      }
      .drag{ display:none; }
      .counts{ justify-content:flex-start; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Crammie</h1>
    <p>Type a label and import sentences. Choose a label from the dropdown to practice. Config & practice sit below the thin divider. ✅ auto-hides; tap a card to highlight in the textarea.</p>
  </header>

  <main class="container">
    <section class="card" id="inputCard">
      <!-- TOP: label input + label dropdown above textarea -->
      <div class="row">
        <div class="pill">
          <label for="labelInput">New Label</label>
          <input id="labelInput" type="text" placeholder="e.g., Act 1 Scene 1" style="background:transparent;color:var(--text);border:0;outline:none;min-width:160px">
        </div>
        <div class="pill">
          <label for="labelFilter">Practice Label</label>
          <select id="labelFilter">
            <option value="" disabled selected>Select a label</option>
          </select>
        </div>
        <button id="btnGenerate">Generate</button>
      </div>

      <div class="grid" style="gap:10px;margin-top:8px">
        <label for="text">Paste text for a new - or selected label</label>
        <textarea id="text" placeholder="Paste the text you want to memorise..."></textarea>
      </div>

      <div class="divider"></div>

      <!-- BELOW TEXTAREA: configuration strip -->
      <div class="row">
        <span class="pill">Cram:
          <label><input type="radio" name="cut" value="3" checked> 3</label>
          <label><input type="radio" name="cut" value="2"> 2</label>
          <label><input type="radio" name="cut" value="1"> 1</label>
        </span>
        <button id="btnScramble">Scramble</button>
        <button id="btnResetOrder" class="btn-ghost">Reset order</button>
        <div class="spacer"></div>
        <span class="pill">Struggle ≥ <input id="struggleN" type="number" min="1" value="1" style="width:54px; background:transparent; color:var(--text); border:0; text-align:center"></span>
        <label><input type="checkbox" id="toggleStruggle"> Show only struggling</label>
      </div>

      <div class="row small">
        <button id="btnCheckOrder" class="btn-ghost">Check order</button>
        <button id="btnResetCounts" class="btn-ghost">Reset counts</button>
        <button id="btnUnhideAll" class="btn-ghost">Unhide all</button>
        <button id="btnClearSession" class="btn-ghost">Clear session</button>
        <button id="btnExportCSV" class="btn-ghost">Copy progress (CSV)</button>
        <span class="spacer"></span>
        <span class="hint">Shortcuts: <span class="kbd">Enter</span>=✅ <span class="kbd">Backspace</span>=❌ <span class="kbd">↑/↓</span>=focus <span class="kbd">S</span>=scramble <span class="kbd">R</span>=reset</span>
      </div>
    </section>

    <section class="card" id="practiceCard">
      <div class="row" style="margin-bottom:6px">
        <strong>Practice</strong>
        <span class="muted small" id="cutNote">(Best with cut = 1)</span>
        <div class="spacer"></div>
        <button id="btnUndo" class="btn-ghost" title="Undo last">↶ Undo</button>
      </div>
      <div id="sentences" class="sentence-list" aria-live="polite"></div>
      <div id="emptyState" class="muted" style="display:none; padding:8px">Choose a label above or import sentences to begin.</div>
      <details class="learned" id="learnedPanel" open>
        <summary>Learned (<span id="learnedCount">0</span>)</summary>
        <div id="learnedList" class="sentence-list" style="margin-top:8px"></div>
      </details>
    </section>
  </main>

  <script>
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  function splitSentences(text){
    return text.trim().replace(/\r\n?/g, "\n").split(/(?<=[.!?])\s+|\n+/).map(s=>s.trim()).filter(Boolean);
  }
  function reattachTrailingPunct(original, cutN){
    if(!cutN) return original;
    return original.replace(/([A-Za-zÀ-ÖØ-öø-ÿ]+(?:'[A-Za-zÀ-ÖØ-öø-ÿ]+)*)([^\sA-Za-zÀ-ÖØ-öø-ÿ]*)/g, (full, w, t)=> (w.length<=cutN? w : w.slice(0, cutN)) + t);
  }

  // Data model
  let state = {
    sentences:[], labels:[], sentenceLabel:[], order:[], learned:new Set(), progress:{},
    cut:3, struggleOnly:false, struggleN:1, selectedLabel:'', undoStack:[],
  };

  function persist(){
    const payload = { sentences:state.sentences, labels:state.labels, sentenceLabel:state.sentenceLabel, order:state.order, learned:[...state.learned], progress:state.progress, cut:state.cut, struggleOnly:state.struggleOnly, struggleN:state.struggleN, selectedLabel:state.selectedLabel };
    localStorage.setItem('crammie:v3', JSON.stringify(payload));
  }
  function load(){
    const raw = localStorage.getItem('crammie:v3'); if(!raw) return;
    try{ const p = JSON.parse(raw);
      state.sentences=p.sentences||[]; state.labels=p.labels||[]; state.sentenceLabel=p.sentenceLabel||[]; state.order=Array.isArray(p.order)?p.order:state.sentences.map((_,i)=>i);
      state.learned=new Set(p.learned||[]); state.progress=p.progress||{}; state.cut=[1,2,3].includes(p.cut)?p.cut:3; state.struggleOnly=!!p.struggleOnly; state.struggleN=Number.isFinite(p.struggleN)?p.struggleN:1; state.selectedLabel=p.selectedLabel||''; }catch(e){ console.warn('load failed',e); }
  }
  function ensureLabel(name){ if(!name) return; if(!state.labels.includes(name)) state.labels.push(name); buildLabelDropdown(); }
  function buildLabelDropdown(){ const sel=$('#labelFilter'); const prev=state.selectedLabel; sel.innerHTML=(state.labels.length?'':'<option value="" disabled selected>Select a label</option>')+state.labels.map(L=>`<option value="${L.replace(/\"/g,'&quot;')}">${L}</option>`).join(''); sel.value=(prev&&state.labels.includes(prev))?prev:(state.labels[0]||''); state.selectedLabel=sel.value||''; }
  function populateTextareaForLabel(label){ const ta=$('#text'); if(!label){ ta.value=''; return;} const parts=state.sentences.filter((_,i)=> state.sentenceLabel[i]===label); ta.value=parts.join('\n'); }
  function showLabelSourceAndSelectSentence(idx){ const label=state.sentenceLabel[idx]; const indices=state.sentences.map((_,i)=>i).filter(i=> state.sentenceLabel[i]===label); const parts=indices.map(i=> state.sentences[i]); const sep='\n'; const source=parts.join(sep); const ta=$('#text'); ta.value=source; const k=indices.indexOf(idx); let start=0; for(let i=0;i<k;i++){ start+=parts[i].length+sep.length; } const end=start+parts[k].length; ta.focus(); if(ta.setSelectionRange) ta.setSelectionRange(start,end); else { ta.selectionStart=start; ta.selectionEnd=end; } ta.classList.add('ta-ping'); setTimeout(()=> ta.classList.remove('ta-ping'), 600); if(/Mobi|Android/i.test(navigator.userAgent)){ ta.blur(); ta.focus(); } }

  function displaySentence(idx){
    const text = reattachTrailingPunct(state.sentences[idx], state.cut);
    const prog = state.progress[idx] || {ok:0,bad:0};
    const total = prog.ok + prog.bad; const ratio = total? Math.round((prog.ok/total)*100):0;
    const card = document.createElement('div'); card.className='card-sentence'; card.draggable=true; card.dataset.idx=idx;
    const drag = document.createElement('div'); drag.className='drag'; drag.textContent='⋮⋮';
    const txt = document.createElement('div'); txt.className='text'; txt.textContent = text;
    const counts = document.createElement('div'); counts.className='counts';
    counts.innerHTML = `<span class="badge">${state.sentenceLabel[idx]||'Label'}</span> <button class="btn btn-ok" data-act="ok" title="Mark correct">✅</button><span class="ok">(${prog.ok})</span><button class="btn btn-bad" data-act="bad" title="Mark incorrect">❌</button><span class="bad">(${prog.bad})</span>`;
    const bar = document.createElement('div'); bar.className='progress'; bar.innerHTML = `<i style="width:${ratio}%"></i>`;

    card.appendChild(drag); card.appendChild(txt); card.appendChild(counts); card.appendChild(bar);

    if((state.progress[idx]?.bad||0) >= state.struggleN){ card.classList.add('struggling'); }

    counts.addEventListener('click', (e)=>{ const btn=e.target.closest('button'); if(!btn) return; const act=btn.dataset.act; if(!act) return; if(act==='ok') markOk(idx); if(act==='bad') markBad(idx); });
    card.addEventListener('click', (e)=>{ if(e.target.closest('button')||e.target.closest('.counts')) return; showLabelSourceAndSelectSentence(idx); });
    card.tabIndex=0; card.addEventListener('focus', ()=>{ $$('.card-sentence').forEach(x=>x.classList.remove('focused')); card.classList.add('focused'); });

    // Desktop DnD
    card.addEventListener('dragstart', (e)=>{ dragSrcIdx = idx; card.classList.add('ghost'); e.dataTransfer.effectAllowed='move'; });
    card.addEventListener('dragend', ()=> card.classList.remove('ghost'));
    card.addEventListener('dragover', (e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='move'; });
    card.addEventListener('drop', (e)=>{ e.preventDefault(); const from = dragSrcIdx; const to = state.order.indexOf(idx); moveCardByPosition(from, to); });

    // Touch reorder
    card.addEventListener('pointerdown', (ev)=>{ if(ev.pointerType !== 'touch') return; ev.preventDefault(); const container=$('#sentences'); const startY=ev.clientY; const cardRect=card.getBoundingClientRect(); const ghost=card.cloneNode(true); Object.assign(ghost.style,{opacity:'.7',position:'fixed',left:cardRect.left+'px',width:cardRect.width+'px',top:cardRect.top+'px',zIndex:1000}); document.body.appendChild(ghost); const placeholder=document.createElement('div'); placeholder.style.height=card.offsetHeight+'px'; placeholder.className='card-sentence'; placeholder.style.border='1px dashed var(--outline)'; card.style.visibility='hidden'; card.parentNode.insertBefore(placeholder, card.nextSibling); function onMove(e){ const dy=e.clientY-startY; ghost.style.top=(cardRect.top+dy)+'px'; const centerY=ghost.getBoundingClientRect().top+ghost.offsetHeight/2; const items=Array.from(container.children); let newPos=0; for(let i=0;i<items.length;i++){ const r=items[i].getBoundingClientRect(); if(centerY>r.top+r.height/2) newPos=i+1; } newPos=Math.min(newPos, items.length-1); if(items[newPos]!==placeholder){ container.insertBefore(placeholder, items[newPos]); } } function onUp(){ ghost.remove(); const items=Array.from(container.children); const newPos=items.indexOf(placeholder); placeholder.replaceWith(card); card.style.visibility=''; window.removeEventListener('pointermove', onMove); window.removeEventListener('pointerup', onUp); moveCardByPosition(idx, newPos); } window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp, {once:true}); });

    return card;
  }

  function render(){
    const list=$('#sentences'); list.innerHTML=''; const learnedList=$('#learnedList'); learnedList.innerHTML='';
    const filter=state.selectedLabel;
    const visibleIdxs=state.order.filter(i=> filter && !state.learned.has(i) && state.sentenceLabel[i]===filter);
    const learnedIdxs=state.order.filter(i=> filter && state.learned.has(i) && state.sentenceLabel[i]===filter);

    let any=false; for(const i of visibleIdxs){ if(state.struggleOnly && (state.progress[i]?.bad||0) < state.struggleN) continue; any=true; list.appendChild(displaySentence(i)); }
    $('#emptyState').style.display = any? 'none':'block';
    for(const i of learnedIdxs){ learnedList.appendChild(renderLearned(i)); }
    $('#learnedCount').textContent = learnedIdxs.length; $('#cutNote').textContent = state.cut===1? '(Progress mode)':'(Progress best at cut = 1)';
    buildLabelDropdown();
    persist();
  }

  function renderLearned(idx){ const wrap=document.createElement('div'); wrap.className='card-sentence'; wrap.style.opacity=.85; const t=document.createElement('div'); t.className='text'; t.textContent=reattachTrailingPunct(state.sentences[idx], state.cut); const counts=document.createElement('div'); counts.className='counts'; const p=state.progress[idx]||{ok:0,bad:0}; counts.innerHTML=`<span class="badge">${state.sentenceLabel[idx]||'Label'}</span> <span class="ok">✅(${p.ok})</span><span class="bad">❌(${p.bad})</span>`; const unhide=document.createElement('button'); unhide.textContent='Unhide'; unhide.className='btn btn-ghost'; unhide.addEventListener('click', ()=>{ state.learned.delete(idx); render(); }); wrap.appendChild(document.createTextNode('✔')); wrap.appendChild(t); wrap.appendChild(counts); wrap.appendChild(unhide); const bar=document.createElement('div'); bar.className='progress'; bar.innerHTML=`<i style="width:${(p.ok/(p.ok+p.bad)||0)*100}%"></i>`; wrap.appendChild(bar); wrap.addEventListener('click', (e)=>{ if(e.target.closest('button')) return; showLabelSourceAndSelectSentence(idx); }); return wrap; }

  // Actions
  let dragSrcIdx=null;
  function moveCardByPosition(fromSentenceIdx, toPosition){ const curPos=state.order.indexOf(fromSentenceIdx); if(curPos<0||toPosition<0) return; const arr=state.order.slice(); arr.splice(curPos,1); arr.splice(toPosition,0,fromSentenceIdx); state.order=arr; render(); }
  function markOk(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.ok++; state.learned.add(idx); render(); }
  function markBad(idx){ const p=state.progress[idx]||(state.progress[idx]={ok:0,bad:0}); p.bad++; render(); }
  function resetOrder(){ state.order=state.sentences.map((_,i)=>i); render(); }
  function resetCounts(){ state.progress={}; render(); }
  function unhideAll(){ state.learned=new Set(); render(); }
  function clearSession(){ localStorage.removeItem('crammie:v3'); state={ sentences:[], labels:[], sentenceLabel:[], order:[], learned:new Set(), progress:{}, cut:3, struggleOnly:false, struggleN:1, selectedLabel:'', undoStack:[] }; buildLabelDropdown(); populateTextareaForLabel(''); render(); }
  function checkOrder(){ const cards=$$('#sentences .card-sentence'); cards.forEach((card, pos)=>{ const idx=Number(card.dataset.idx); const ok=idx===pos; card.style.outline = ok? '2px solid rgba(34,197,94,.6)' : '2px solid rgba(239,68,68,.4)'; }); setTimeout(()=>{ cards.forEach(c=> c.style.outline=''); }, 1200); }
  function copyCSV(){ const rows=[['index','sentence','label','cut','ok','bad','learned']]; state.sentences.forEach((s,i)=>{ const p=state.progress[i]||{ok:0,bad:0}; rows.push([i, s.replaceAll('\n',' '), state.sentenceLabel[i]||'', state.cut, p.ok, p.bad, state.learned.has(i)?1:0]); }); const csv=rows.map(r=> r.map(cell=> '"'+String(cell).replaceAll('"','""')+'"').join(',')).join('\n'); if(navigator.clipboard && window.isSecureContext){ navigator.clipboard.writeText(csv).then(()=> alert('Progress copied to clipboard as CSV.')).catch(fallback);} else { fallback(); } function fallback(){ const ta=document.createElement('textarea'); ta.value=csv; ta.style.position='fixed'; ta.style.opacity='0'; document.body.appendChild(ta); ta.select(); try{ document.execCommand('copy'); alert('Progress copied to clipboard as CSV.'); }catch(e){ alert('Copy failed. Select text manually.'); } ta.remove(); } }

  // Import flow
  $('#btnGenerate').addEventListener('click', ()=>{ const label=($('#labelInput').value||'').trim(); const t=($('#text').value||'').trim(); if(!label){ alert('Please enter a label for this import.'); return; } if(!t){ alert('Please paste some text.'); return; } const parts=splitSentences(t); if(!parts.length){ alert('No sentences found.'); return; } ensureLabel(label); const baseLen=state.sentences.length; for(const s of parts){ state.sentences.push(s); state.sentenceLabel.push(label); } state.order = state.order.concat(parts.map((_,i)=> baseLen + i)); state.selectedLabel=label; buildLabelDropdown(); render(); populateTextareaForLabel(label); });

  // Controls
  $$('#inputCard input[name="cut"]').forEach(r=> r.addEventListener('change', ()=>{ state.cut=Number(document.querySelector('input[name="cut"]:checked').value); render(); }));
  $('#btnScramble').addEventListener('click', ()=>{ const arr=state.order.slice(); for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } state.order=arr; render(); });
  $('#btnResetOrder').addEventListener('click', resetOrder);
  $('#btnResetCounts').addEventListener('click', resetCounts);
  $('#btnUnhideAll').addEventListener('click', unhideAll);
  $('#btnClearSession').addEventListener('click', clearSession);
  $('#btnCheckOrder').addEventListener('click', checkOrder);
  $('#btnExportCSV').addEventListener('click', copyCSV);
  $('#labelFilter').addEventListener('change', (e)=>{ state.selectedLabel=e.target.value; render(); populateTextareaForLabel(state.selectedLabel); });
  $('#toggleStruggle').addEventListener('change', (e)=>{ state.struggleOnly=e.target.checked; render(); });
  $('#struggleN').addEventListener('change', (e)=>{ state.struggleN=clamp(parseInt(e.target.value||'1',10),1,999); render(); });

  // Boot
  load(); buildLabelDropdown(); populateTextareaForLabel(state.selectedLabel); render();
  </script>
</body>
</html>
